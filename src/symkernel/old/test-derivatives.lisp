(in-package :deriv-tests)

(defun simplify (expr)
  (declare (optimize (debug 3)))
  (labels
      ((flat (op args)
         (mapcan (lambda (a)
                   (let ((sa (simplify a)))
                     (if (and (consp sa) (eq (car sa) op))
                         (cdr sa)
                         (list sa))))
                 args))
       (sort-args (args)
         (sort (copy-list args)
               (lambda (a b) (string< (prin1-to-string a)
                                      (prin1-to-string b)))))
       (sum-canonical (args)
         (let* ((a (flat '+ args))
                (nums (remove-if-not #'numberp a))
                (non  (remove-if     #'numberp a))
                (s    (reduce #'+ nums :initial-value 0))
                (ht   (make-hash-table :test #'equal))
                out)
           ;; count identical nonnumeric terms
           (dolist (tt non) (incf (gethash tt ht 0)))
           (maphash (lambda (term k)
                      (push (if (= k 1) term (list '* k term)) out))
                    ht)
           (when (/= s 0) (push s out))
           (setf out (sort-args out))
           (cond
             ((null out) 0)
             ((null (cdr out)) (car out))
             (t (cons '+ out)))))
       (prod-canonical (args)
         (let* ((a (flat '* args))
                (sa (mapcar #'simplify a)))
           (when (find 0 sa) (return-from prod-canonical 0))
           (let* ((nums (remove-if-not #'numberp sa))
                  (non  (remove-if     #'numberp sa))
                  (p    (reduce #'* nums :initial-value 1)))
             ;; remove multiplicative identity
             (when (= p 1) (setf p nil))
             (setf non (sort-args non))
             (let ((out (append (when p (list p)) non)))
               (cond
                 ((null out) 1)
                 ((null (cdr out)) (car out))
                 (t (cons '* out))))))))
    (cond
      ((atom expr) expr)
      ((eq (car expr) '+) (sum-canonical (cdr expr)))
      ((and (eq (car expr) '*) (= (length expr) 3) (eql (second expr) 1))
       (third expr))
      ((and (eq (car expr) '*) (= (length expr) 3) (eql (third expr) 1))
       (second expr))
      ((eq (car expr) '*) (prod-canonical (cdr expr)))
      ((eq (car expr) 'expt)
       (let ((b (simplify (cadr expr)))
             (e (simplify (caddr expr))))
         (cond ((numberp e)
                (case e
                  (0 1) (1 b) (t (list 'expt b e))))
               (t (list 'expt b e)))))
      (t (cons (car expr) (mapcar #'simplify (cdr expr)))))))


(defun simplify-deriv (expression var)
  (simplify (opt-exp:deriv expression var)))


(defun num-eval (expr env)
  (declare (optimize (debug 3)))
  (labels
      ((lookup (sym)
         (let ((pair (assoc sym env)))
           (if pair (cdr pair)
               (error "Unbound symbol ~a in num-eval." sym))))
       (safe-div (num den)
         (if (zerop den)
             (error "Division by zero in num-eval: ~a / ~a" num den)
             (/ num den))))
    (cond
      ((numberp expr) expr)
      ((symbolp expr) (lookup expr))
      ((consp expr)
       (let* ((op   (car expr))
              (vals (mapcar (lambda (arg) (num-eval arg env)) (cdr expr))))
         (case op
           (+ (reduce #'+ vals :initial-value 0))
           (* (reduce #'* vals :initial-value 1))
           (/ (cond
                ((null vals) (error "(/) with no arguments."))
                ((null (cdr vals)) (safe-div 1 (car vals)))      ; reciprocal
                (t (reduce (lambda (acc val) (safe-div acc val))
                           (cdr vals)
                           :initial-value (car vals)))))
           (expt (expt (first vals) (second vals)))
           (sin (sin (first vals)))
           (cos (cos (first vals)))
           (atan2 (atan (second vals) (first vals))) ; Common lisp evaluates like (atan x y) not like C atan2(y,x)
           (tan (tan (first vals)))
           (exp (exp (first vals)))
           (log (log (first vals)))
           (otherwise (error "Unknown operator ~a in num-eval." op)))))
      (otherwise (error "Bad expression in num-eval: ~a" expr)))))


(defun approx-equal (a b &optional (eps 1e-4))
  (declare (optimize (debug 3)))
  (< (abs (- a b)) eps))

(defun numeric-deriv-check (expr var x0)
  (declare (optimize (debug 3)))
  (let* ((env `((,var . ,x0)))
         (h 1d-10)
         (fp (num-eval expr `((,var . ,(+ x0 h)))))
         (fm (num-eval expr `((,var . ,(- x0 h)))))
         (fd-approx (/ (- fp fm) (* 2 h)))
         (sym (simplify-deriv expr var))
         (fd-sym (num-eval sym env))
         (ae (approx-equal fd-approx fd-sym)))
    (values ae fd-sym fd-approx)))

(defun quick-check (expr var &optional (trials 20))
  (declare (optimize (debug 3)))
  (loop repeat trials
        for x = (- (random 4.0) 2.0)
        unless (numeric-deriv-check expr var x)
          do (progn
               (break "Check the results")
               (return (list :fail expr var x (simplify-deriv expr var))))
        finally (return :ok)))

(defun assert-equal (a b)
  (declare (optimize (debug 3)))
  (unless (equal (simplify a) (simplify b))
    (error "Expected ~a but got ~a" b a)))

(defun test-symbolic ()
  (declare (optimize (debug 3)))
  (assert-equal (simplify-deriv 'x 'x) 1)
  (assert-equal (simplify-deriv '5 'x) 0)
  (assert-equal (simplify-deriv '(* x x) 'x) '(* 2 x))
  (assert-equal (simplify-deriv '(+ (* 3 x) 7) 'x) 3)
  (assert-equal (simplify-deriv '(expt x 3) 'x) '(* 3 (expt x 2)))
  (assert-equal (simplify-deriv '(sin x) 'x) '(cos x))
  (assert-equal (simplify-deriv '(cos x) 'x) '(* -1 (sin x)))
  (assert-equal (simplify-deriv '(exp x) 'x) '(exp x))
  (assert-equal (simplify-deriv '(log x) 'x) '(* (expt x -1) 1))
  :ok)


(defun random-poly (var &optional (degree 4))
  (declare (optimize (debug 3)))
  (labels ((rp (d)
             (if (zerop d)
                 (random 5)
                 (list '+
                       (list '* (random 5) (list 'expt var d))
                       (rp (1- d))))))
    (rp degree)))

(defun test-polynomials (&optional (trials 30))
  (declare (optimize (debug 3)))
  (loop repeat trials
        for p = (random-poly 'x)
        for result = (quick-check p 'x)
        unless (eq result :ok)
          do (error "~a" result)
        finally (return :ok)))

(defun test-mixed ()
  (declare (optimize (debug 3)))
  (let ((exprs
          '((sin (* 3 x))
            (* (sin x) (cos x))
            (/ (sin x) (exp x))
            (+ (expt (sin x) 3) (* x x))
            (log (* x (exp x))))))
    (loop for e in exprs
          for r = (quick-check e 'x)
          unless (eq r :ok)
            do (error "~a" r)
          finally (return :ok))))

(defun run-all-deriv-tests ()
  (format t "~&Symbolic tests: ~a~%" (test-symbolic))
  (format t "Random polynomial tests: ~a~%" (test-polynomials))
  (format t "Mixed tests: ~a~%" (test-mixed))
  (format t "~&All deriv tests passed.~%"))

